# -*- coding: utf-8 -*-
"""hw1_q5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_DrFPktDn9Ckx1BQVedT9dv5s_aq4kuT
"""

#Question 5
cipher = "IDSEOYLTVVDO?PSAUEKZO?LQIILQMP?LQNP!YSFNGSDBJZRZYTZTPS?EVYF,?LQ ,SAXSWTFXFD"

alphabet = {'A':0, 'B':1, 'C':2, 'D':3, 'E':4, 'F':5, 'G':6, 'H':7, 'I':8, 'J':9, 'K':10, 'L':11, 'M':12, 'N':13, 'O':14, 'P':15, 
                'Q':16, 'R':17, 'S':18, 'T':19, 'U':20, 'V':21, 'W':22, 'X':23, 'Y':24, 'Z':25,     ' ':26, '.':27, ',': 28, '!': 29, '?':30}
alphabet_inv = {0:'A', 1:'B', 2:'C', 3:'D', 4:'E', 5:'F', 6:'G', 7:'H', 8:'I', 9:'J', 10:'K', 11:'L', 12:'M', 13:'N', 14:'O', 15:'P',
                 16:'Q', 17:'R', 18:'S', 19:'T', 20:'U', 21:'V', 22:'W', 23:'X', 24:'Y', 25:'Z', 26:' ' , 27:'.' , 28:',' , 29:'!' , 30:'?' }
# The extended Euclidean algorithm (EEA)
def egcd(a, b):
    x,y, u,v = 0,1, 1,0
    while a != 0:
        q, r = b//a, b%a
        m, n = x-u*q, y-v*q
        b,a, x,y, u,v = a,r, u,v, m,n
    gcd = b
    return gcd, x, y
    
# Modular inverse algorithm that uses EEA
def modinv(a, m):
    if a < 0:
        a = m+a
    gcd, x, y = egcd(a, m)
    if gcd != 1:
        return None  # modular inverse does not exist
    else:
        return x % m

def gcd(a, b): #modified egcd so that it would only return gcd
  x,y, u,v = 0,1, 1,0
  while a != 0:
      q, r = b//a, b%a
      m, n = x-u*q, y-v*q
      b,a, x,y, u,v = a,r, u,v, m,n
  gcd = b
  return gcd

keys = {} #find all possible key pairs
for b in range(29791): #31^3 is 29791
  a = ((22261 - b) * modinv(26683,29791)) % 29791 #22261 is the encoding of XFD and 26683 is the encoding of .XX both last trigrams in cipher and plaintexts
  keys[a] = b

for k in keys: #try all possible key pairs (exhaustive search)
  alpha = k
  beta = keys[k]
  plain = ""
  for i in range(0,len(cipher),3): #take 3 letters at a time
    encoded = alphabet[cipher[i]]*31*31 + alphabet[cipher[i+1]]*31 + alphabet[cipher[i+2]]
    if gcd(alpha,29791) == 1: #if x value can be found
      x1 = ((encoded - beta) * modinv(alpha,29791)) % 29791
      a = ""
      b = ""
      c = ""
      for k in range(31):
        if (x1 - k) % 31 == 0: #since the equation is in the form a*31*31 + b*31 + c, when we subtract c, it should be a multiple of 31
          c = alphabet_inv[k]
          x2 = (x1 - k) / 31
          for j in range(31):
            if (x2 - j) % 31 == 0: #since the equation here is like a*31 + b, when we subtract b, "a" should be a multiple of 31
              b = alphabet_inv[j]
              a = alphabet_inv[(x2 - j) / 31]
              break
      plain = plain + a + b + c #add all 3 letters
  if "THE" in plain: #print if THE - most popular trigram is in the plaintext (otherwise too many outputs)
   print("When alpha is", alpha, "and beta is", beta, ":", plain)
gamma = modinv(129, 29791)
print("For the decryption key gamma is", gamma)
theta = 29791 - (gamma * 6119) % 29791
print("For the decryption key theta is", theta)